package sneps.snepslog;

import java.io.*;
import java_cup.runtime.*;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Set;

import sneps.network.Node;
import sneps.network.PropositionNode;
import sneps.network.VariableNode;
import sneps.network.Network;
import sneps.network.classes.CaseFrame;
import sneps.network.classes.Relation;
import sneps.network.classes.Semantic;
import sneps.network.classes.SemanticHierarchy;
import sneps.network.classes.Wire;
import sneps.network.classes.term.Base;
import sneps.network.paths.Path;
import sneps.network.paths.BangPath;
import sneps.network.paths.EmptyPath;
import sneps.network.paths.BUnitPath;
import sneps.network.paths.FUnitPath;
import sneps.network.paths.CFResBUnitPath;
import sneps.network.paths.CFResFUnitPath;
import sneps.network.paths.AndPath;
import sneps.network.paths.ComposePath;
import sneps.network.paths.ConversePath;
import sneps.network.paths.DomainRestrictPath;
import sneps.network.paths.IrreflexiveRestrictPath;
import sneps.network.paths.KPlusPath;
import sneps.network.paths.KStarPath;
import sneps.network.paths.OrPath;
import sneps.network.paths.RangeRestrictPath;
import sneps.snebr.Controller;
import sneps.exceptions.CannotFindCaseFrameException;
import sneps.exceptions.ContextNameDoesntExistException;
import sneps.exceptions.ContradictionFoundException;
import sneps.exceptions.DuplicatePropositionException;
import sneps.exceptions.InvalidArgumentsException;
import sneps.exceptions.InvalidWffNameException;
import sneps.exceptions.ModeOneOnlyException;
import sneps.exceptions.ModeThreeOnlyException;
import sneps.exceptions.NodeNotFoundInNetworkException;
import sneps.exceptions.NotAPropositionNodeException;
import sneps.exceptions.RelationDoesntExistException;
import sneps.exceptions.SemanticAlreadySetException;
import sneps.exceptions.IllegalAtomicSymbolException;
import sneps.exceptions.EquivalentNodeException;
import sneps.gui.Main;


parser code {:
String command;
String warning = "";
:};
	
/* Terminals (tokens returned by the scanner). */

terminal ACTIVATE,
         BANG,
         DOT,
         ADD_TO_CONTEXT,
         ASK,
         ASKIFNOT,
         ASKWH,
         ASKWHNOT,
         BELIEFS_ABOUT,
         BR_MODE,
         AUTO,
         MANUAL,
         CLEAR_INFER,
         CLEARKB,
         COPYRIGHT,
         DEFINE_FRAME,
         DEFINE_PATH,
         DEFINE_SEMANTIC,
         DEFINE_RELATION,
         QUESTION_MARK,
         DESCRIBE_CONTEXT,
         DESCRIBE_TERMS,
         EXPERT,
         LIST_ASSERTED_WFFS,
         LIST_CONTEXTS,
         LIST_TERMS,
         LIST_WFFS,
         LOAD,
         NORMAL,
         PERFORM,
         REMOVE_FROM_CONTEXT,
         SET_CONTEXT,
         SET_DEFAULT_CONTEXT,
         SET_MODE_1,
         SET_MODE_2,
         SET_MODE_3,
         SHOW,
         TRACE,
         UNDEFINE_PATH,
         UNLABELED,
         UNTRACE,
         INFERENCE,
         ACTING,
         EQUALITY,
         IMPLICATION,
         OR_ENTAILMENT,
         AND_ENTAILMENT,
         NOT,
         ANDOR,
         AND,
         OR,
         NAND,
         NOR,
         XOR,
         IFF,
         THRESH,
         ALL,
         COMMA,
         COLON,
         OPEN_PARAN,
         CLOSE_PARAN,
         OPEN_CURLY,
         CLOSE_CURLY,
         WITHSOME,
         WITHALL,
         IFDO,
         WHENDO,
         WHENEVERDO,
         ACTPLAN,
         EFFECT,
         GOALPLAN,
         PRECONDITION,
         KPLUS,
         KSTAR,
         COMPOSE,
         CONVERSE,
         IRREFLEXIVE_RESTRICT,
         DOMAIN_RESTRICT,
         RANGE_RESTRICT,
         CFRES,
         BANGPATH,
         EMPTYPATH;

terminal String FILEPATH,
                STRING_LIT,
                INT_LIT,
                IDENTIFIER,
                NUMERICAL_ENTAILMENT,
                EXPAND,
         	    REDUCE,
         	    NONE,
         	    WFF;

/* Non-terminals */

nonterminal String command,
                   wffCommand,
                   snepslogCommand,
                   snepslogFunction,
                   terminalPunctuation,
                   optionalDot,
                   optionalTerminalPunctuation,
                   andOrEquality,
                   wffName,
                   optionalIdentifier;
                   
nonterminal ArrayList<String>  identifiers,
                               identifiers_list;
                   
nonterminal Path path,
                 snepsPath;
nonterminal LinkedList<Path> paths;
                               
nonterminal Node wff,
                 infixedTerm,
                 entailment,
                 prefixedTerm,
                 negatedTerm, 
                 andorTerm, 
                 setTerm, 
                 threshTerm, 
                 allTerm, 
                 atomicTerm,
                 withsomeTerm,
                 withallTerm,
                 ifdoTerm,
                 whendoTerm,
                 wheneverdoTerm,
                 actplanTerm,
                 effectTerm,
                 goalplanTerm,
                 preconditionTerm,
                 snepslogSymbol,
                 qvar;

nonterminal ArrayList<Node> pTermSet,
                            termSet,
                            termSequence,
                            prefixedTerms, 
                            symbolSequence,
                            snepslogSymbols,
                            optionalPTermSet;
                             
nonterminal ArrayList<ArrayList<Node>> termSetSequence,
                                       termSets;

/* Precedences */


/* The grammar */

command ::= snepslogCommand:sc
		{: 
			if(warning.length()!=0){
				warning+="\n";
			}
			RESULT = warning + sc;
		:}
		| wffCommand:wc
		{: 
			if(warning.length()!=0){
				warning+="\n";
			}
			RESULT = warning + wc;
		:};		
				
wffCommand ::= wff:w terminalPunctuation:tp
		   {: 
		   		if(w.getTerm() instanceof Base){
		   			throw new IllegalAtomicSymbolException("wff must not be an atomic symbol");
		   		}
				ArrayList<Node> nodes = new ArrayList<>();
				ArrayList<Node> matchingNodes = new ArrayList<>();
				switch (tp) {
				case ".":
					try {
						Controller.addPropToCurrentContext(w.getId());
						nodes.add(w);
						RESULT = AP.displayWffs(nodes);
					} catch (DuplicatePropositionException e) {
						RESULT = e.getMessage();
					} catch (NotAPropositionNodeException e) {
						RESULT = e.getMessage();
					} catch (NodeNotFoundInNetworkException e) {
						RESULT = e.getMessage();
					} catch (ContextNameDoesntExistException e) {
						RESULT = e.getMessage();
					} catch (ContradictionFoundException e) {
						Main.userAction(e.getContradictoryHyps());
						RESULT = "The GUI is used to handle the contradiction!";
					} catch (Exception e) {
						RESULT = e.getMessage();
					}
					break;
				case "!":
					try {
						nodes = AP.forwardInference(w, "!");
						RESULT = AP.displayWffs(nodes);
					} catch (NotAPropositionNodeException e) {
						RESULT = e.getMessage();
					} catch (NodeNotFoundInNetworkException e) {
						RESULT = e.getMessage();
					} catch (Exception e) {
						RESULT = e.getMessage();
					}
					break;
				case "??":
					try{
					matchingNodes = AP.match(w);
						for(int i=0;i<matchingNodes.size();i++){
							if(Controller.getCurrentContext().isAsserted((PropositionNode) matchingNodes.get(i))){
								nodes.add(matchingNodes.get(i));
							}
						}
						if (!nodes.isEmpty()) {
							RESULT = AP.displayWffs(nodes);
						} else {
							RESULT = "";
						}
						}catch (NotAPropositionNodeException e) {
							RESULT = e.getMessage();
						} catch (NodeNotFoundInNetworkException e) {
							RESULT = e.getMessage();
						} catch (Exception e) {
							RESULT = e.getMessage();
						}
					break;
				case "?":
						try {
							matchingNodes = AP.match(w);
							for(int i=0;i<matchingNodes.size();i++){
								ArrayList<Node> temp = AP.deduce(matchingNodes.get(i), "?", -1, -1);
								for(int j=0;j<temp.size();j++){
									nodes.add(temp.get(j));
								}
							}
							RESULT = AP.displayWffs(nodes);
						} catch (NotAPropositionNodeException e) {
							RESULT = e.getMessage();
						} catch (NodeNotFoundInNetworkException e) {
							RESULT = e.getMessage();
						} catch (Exception e) {
							RESULT = e.getMessage();
						}
						break;
				default:
					try{
						if (tp.startsWith("ONE")) {
							int i = Integer.parseInt(tp.substring(3));
							matchingNodes = AP.match(w);
					    		for(int a=0;a<matchingNodes.size();a++){
								ArrayList<Node> temp = AP.deduce(matchingNodes.get(a), "?", i, -1);
								for(int b=0;b<temp.size();b++){
									nodes.add(temp.get(b));
								}
							}
							RESULT = AP.displayWffs(nodes);
						} else {
							int i = Integer.parseInt(tp.substring(3).split(",")[0]);
							int j = Integer.parseInt(tp.substring(3).split(",")[1]);
							matchingNodes = AP.match(w);
							for(int a=0;a<matchingNodes.size();a++){
								ArrayList<Node> temp = AP.deduce(matchingNodes.get(a), "?", i, j);
								for(int b=0;b<temp.size();b++){
									nodes.add(temp.get(b));
								}
							}
							RESULT = AP.displayWffs(nodes);
						}
						} catch (NotAPropositionNodeException e) {
							RESULT = e.getMessage();
						} catch (NodeNotFoundInNetworkException e) {
							RESULT = e.getMessage();
						} catch (Exception e) {
							RESULT = e.getMessage();
						}
					break;
				}
		   :};	
				
snepslogCommand ::= ACTIVATE wff:w optionalDot
				{: 
					try {
						ArrayList<Node> output = AP.forwardInference(w, "activate");
						RESULT = AP.displayWffs(output);
					} catch (NotAPropositionNodeException e) {
						RESULT = e.getMessage();
					} catch (NodeNotFoundInNetworkException e) {
						RESULT = e.getMessage();
					} catch (Exception e) {
						RESULT = e.getMessage();
					}				
				:}
				| ACTIVATE BANG wff:w optionalTerminalPunctuation
				{: 
                		try {
						ArrayList<Node> output = AP.forwardInference(w, "activate!");
						RESULT = AP.displayWffs(output);
					} catch (NotAPropositionNodeException e) {
						RESULT = e.getMessage();
					} catch (NodeNotFoundInNetworkException e) {
						RESULT = e.getMessage();
					} catch (Exception e) {
						RESULT = e.getMessage();
					}		
				:}
				| ADD_TO_CONTEXT IDENTIFIER:id termSet:ts optionalDot
				{: 
					try {
						Controller.addPropsToContext(id, AP.arrayListToPropositionSet(ts));
						RESULT = "";
					} catch (NotAPropositionNodeException e) {
						RESULT = e.getMessage();
					} catch (NodeNotFoundInNetworkException e) {
						RESULT = e.getMessage();
					} catch (ContextNameDoesntExistException e) {
						RESULT = e.getMessage();
					} catch (ContradictionFoundException e) {
						Main.userAction(e.getContradictoryHyps());
						RESULT = "The GUI is used to handle the contradiction!";
					} catch (Exception e) {
						RESULT = e.getMessage();
					}
				:}
				| ASK wff:w optionalTerminalPunctuation
				{: 
					try {
						ArrayList<Node> output = AP.deduce(w, "ask", -1, -1);
						RESULT = AP.displayWffs(output);
					} catch (NotAPropositionNodeException e) {
						RESULT = e.getMessage();
					} catch (NodeNotFoundInNetworkException e) {
						RESULT = e.getMessage();
					} catch (Exception e) {
						RESULT = e.getMessage();
					}	
				:}
				| ASKIFNOT wff:w optionalTerminalPunctuation
				{: 
					try {
						ArrayList<Node> output = AP.deduce(w, "askifnot", -1, -1);
						RESULT = AP.displayWffs(output);
					} catch (NotAPropositionNodeException e) {
						RESULT = e.getMessage();
					} catch (NodeNotFoundInNetworkException e) {
						RESULT = e.getMessage();
					} catch (Exception e) {
						RESULT = e.getMessage();
					}	
				:}
				| ASKWH wff:w optionalTerminalPunctuation
				{: 
					try {
						ArrayList<Node> output = AP.deduce(w, "askwh", -1, -1);
						RESULT = AP.displayWffs(output);
					} catch (NotAPropositionNodeException e) {
						RESULT = e.getMessage();
					} catch (NodeNotFoundInNetworkException e) {
						RESULT = e.getMessage();
					} catch (Exception e) {
						RESULT = e.getMessage();
					}	
				:}
				| ASKWHNOT wff:w optionalTerminalPunctuation
				{: 
					try {
						ArrayList<Node> output = AP.deduce(w, "askwhnot", -1, -1);
						RESULT = AP.displayWffs(output);
					} catch (NotAPropositionNodeException e) {
						RESULT = e.getMessage();
					} catch (NodeNotFoundInNetworkException e) {
						RESULT = e.getMessage();
					} catch (Exception e) {
						RESULT = e.getMessage();
					}	
				:}
				| BELIEFS_ABOUT pTermSet:pts optionalDot
				{: 
					try {
						RESULT = AP.displayWffs(AP.beliefsAbout(pts));
					} catch (NotAPropositionNodeException e) {
						RESULT = e.getMessage();
					} catch (NodeNotFoundInNetworkException e) {
						RESULT = e.getMessage();
					} catch (Exception e) {
						RESULT = e.getMessage();
					}	
				:}
				| BR_MODE optionalDot
				{: 
					boolean auto = Controller.isAutomaticBR();
					if(auto){
						RESULT = "Belief revision mode currently set to auto";
					}else{
						RESULT = "Belief revision mode currently set to manual";
					}
				:}
				| BR_MODE AUTO optionalDot
				{: 
					Controller.setAutomaticBR(true);
					RESULT = "Belief revision mode will now be set to auto.";
				:}
				| BR_MODE MANUAL optionalDot
				{: 
					Controller.setAutomaticBR(false);
					RESULT = "Belief revision mode will now be set to manual.";
				:}
				| CLEAR_INFER optionalDot
				{: 
					AP.clearInfer();
					RESULT = "";
				:}
				| CLEARKB optionalDot
				{: 
					AP.clearKnowledgeBase();
					RESULT = "The knowledge base is cleared.";
				:}
				| COPYRIGHT optionalDot
				{: 
					RESULT = "copyright statement goes here.";
				:}
				| DEFINE_FRAME IDENTIFIER:id1 IDENTIFIER:id2 identifiers_list:idl optionalDot
				{: 
					try{
						if(AP.getSnepslogMode()==3){
							AP.createModeThreeCaseFrame(id1, id2, idl, null);
							RESULT = "";
						}else{
							RESULT = "You can only use this command in Mode 3.";
						}
					} catch(RelationDoesntExistException e){
						RESULT = e.getMessage();
					} catch (Exception e) {
						RESULT = e.getMessage();
					}
				:}
				| DEFINE_FRAME IDENTIFIER:id1 IDENTIFIER:id2 identifiers_list:idl STRING_LIT:sl optionalDot
				{: 
					try{
						if(AP.getSnepslogMode()==3){
							AP.createModeThreeCaseFrame(id1, id2, idl, sl);
							RESULT = "";
						}else{
							RESULT = "You can only use this command in Mode 3.";
						}
					} catch(RelationDoesntExistException e){
						RESULT = e.getMessage();
					} catch (Exception e) {
						RESULT = e.getMessage();
					}
				:}
				| DEFINE_PATH IDENTIFIER:id snepsPath:sp optionalDot
				{: 
					try{
						if(AP.getSnepslogMode()==3){
							Network.definePath(Network.getRelation(id),sp);
							RESULT = "";
						}else{
							RESULT = "You can only use this command in Mode 3.";
						}
					} catch(RelationDoesntExistException e){
						RESULT = e.getMessage();
					} catch (Exception e) {
						RESULT = e.getMessage();
					}
				:}
				| DEFINE_SEMANTIC IDENTIFIER:id optionalDot
				{: 
					if(AP.getSnepslogMode()==3){
						AP.defineSemantic(id,null,null);
						RESULT = "";
					}else{
						RESULT = "You can only use this command in Mode 3.";
					}
				:}
				| DEFINE_SEMANTIC IDENTIFIER:id1 IDENTIFIER:id2 optionalDot
				{: 
					if(AP.getSnepslogMode()==3){
						AP.defineSemantic(id1,id2,null);
						RESULT = "";
					}else{
						RESULT = "You can only use this command in Mode 3.";
					}
				:}
				| DEFINE_SEMANTIC IDENTIFIER:id1 IDENTIFIER:id2 identifiers_list:ids optionalDot
				{: 
					if(AP.getSnepslogMode()==3){
						AP.defineSemantic(id1,id2,ids);
						RESULT = "";
					}else{
						RESULT = "You can only use this command in Mode 3.";
					}
				:}
				| DEFINE_RELATION IDENTIFIER:id1 IDENTIFIER:id2 optionalDot
				{: 
					if(AP.getSnepslogMode()==3){
						Network.defineRelation(id1, id2);
						RESULT = "";
					}else{
						RESULT = "You can only use this command in Mode 3.";
					}
				:}
				| DEFINE_RELATION IDENTIFIER:id1 IDENTIFIER:id2 EXPAND:a INT_LIT:l optionalDot
				{: 
					if(AP.getSnepslogMode()==3){
						Network.defineRelation(id1, id2, a, Integer.valueOf(l));
						RESULT = "";
					}else{
						RESULT = "You can only use this command in Mode 3.";
					}
				:}
				| DEFINE_RELATION IDENTIFIER:id1 IDENTIFIER:id2 REDUCE:a INT_LIT:l optionalDot
				{: 
					if(AP.getSnepslogMode()==3){
						Network.defineRelation(id1, id2, a, Integer.valueOf(l));
						RESULT = "";
					}else{
						RESULT = "You can only use this command in Mode 3.";
					}
				:}
				| DEFINE_RELATION IDENTIFIER:id1 IDENTIFIER:id2 NONE:a INT_LIT:l optionalDot
				{: 
					if(AP.getSnepslogMode()==3){
						Network.defineRelation(id1, id2, a, Integer.valueOf(l));
						RESULT = "";
					}else{
						RESULT = "You can only use this command in Mode 3.";
					}
				:}
				| DESCRIBE_CONTEXT optionalIdentifier:oid optionalDot
				{: 
					if(oid!=null){
						RESULT = Controller.contextToString(oid);
					}else{
						RESULT = Controller.contextToString(Controller.getCurrentContextName());
					}
				:}
				| DESCRIBE_TERMS optionalPTermSet:opts optionalDot
				{: 
					if(opts!=null){
						RESULT = AP.describeTerms(opts);
					}else{
						RESULT = AP.describeTerms(AP.getAllClosedNodesFromTheNetwork());
					}
				:}
				| EXPERT optionalDot
				{: 
					if(!AP.getPrintingMode().equals("expert")) {
						AP.setPrintingMode("expert");
						RESULT = "expert mode is turned on.";
					}else{
						RESULT = "expert mode is already in use.";
					}
				:}
				| LIST_ASSERTED_WFFS optionalIdentifier:oid optionalDot
				{: 
				try{
					if(oid!=null){
						RESULT = AP.displayWffs(AP.propositionSetToArrayList(Controller.getContextByName(oid).allAsserted()));
					}else{
						RESULT = AP.displayWffs(AP.propositionSetToArrayList(Controller.getCurrentContext().allAsserted()));
					}
				}  catch (NotAPropositionNodeException e) {
						RESULT = e.getMessage();
				} catch (NodeNotFoundInNetworkException e) {
					RESULT = e.getMessage();
				} catch (Exception e) {
					RESULT = e.getMessage();
				}	
				:}
				| LIST_CONTEXTS optionalDot
				{: 
					Set<String> contexts = Controller.getAllNamesOfContexts();
					String output = "";
					for (String context : contexts) {
						output+=context+'\n';
					}
					if(output.length()!=0) {
						output=output.substring(0, output.length()-1);
					}
					RESULT = output;		
				:}
				| LIST_TERMS optionalPTermSet:opts optionalDot
				{: 
					try{
						if(opts!=null){
							RESULT = AP.displayTerms(AP.getMolecular(opts));
						}else{
							RESULT = AP.displayTerms(AP.getAllMolecularNodesFromTheNetwork());
						}
					}  catch (NotAPropositionNodeException e) {
						RESULT = e.getMessage();
					} catch (NodeNotFoundInNetworkException e) {
						RESULT = e.getMessage();
					} catch (Exception e) {
						RESULT = e.getMessage();
					}	
				:}
				| LIST_WFFS optionalDot
				{: 
					try{
						RESULT = AP.displayWffs(AP.propositionSetToArrayList(Controller.allAsserted()));
					}  catch (NotAPropositionNodeException e) {
						RESULT = e.getMessage();
					} catch (NodeNotFoundInNetworkException e) {
						RESULT = e.getMessage();
					} catch (Exception e) {
						RESULT = e.getMessage();
					}	
				:}
				| LOAD FILEPATH:fp optionalDot
				{: 
					RESULT = AP.loadFile(fp);
				:}
				| NORMAL optionalDot
				{: 
					if(!AP.getPrintingMode().equals("normal")) {
						AP.setPrintingMode("normal");
						RESULT = "normal mode is turned on.";
					}else{
						RESULT = "normal mode is already in use.";
					}
				:}
				| PERFORM atomicTerm:at optionalDot
				{: 
					AP.perform(at);
					RESULT = "";
				:}
				| REMOVE_FROM_CONTEXT IDENTIFIER:id pTermSet:pts
				{: 
					try {
						Controller.removeHypsFromContext(AP.arrayListToPropositionSet(pts),id);
						RESULT = "";
					} catch (ContextNameDoesntExistException e) {
						RESULT = e.getMessage();
					}
				:}
				| SET_CONTEXT IDENTIFIER:id optionalPTermSet:opts
				{: 
					try{
						if(opts!=null){
							Controller.createContext(id, AP.arrayListToPropositionSet(opts));
						}else{
							Controller.createContext(id);
						}
						RESULT = "";
					}  catch (ContradictionFoundException e) {
						Main.userAction(e.getContradictoryHyps());
						RESULT = "The GUI is used to handle the contradiction!";
					} catch (Exception e) {
						RESULT = e.getMessage();
					}
				:}
				| SET_DEFAULT_CONTEXT IDENTIFIER:id
				{: 
					try{
						Controller.setCurrentContext(id);
						RESULT = "";
					} catch (ContextNameDoesntExistException e) {
						RESULT = e.getMessage();
					}catch (Exception e) {
						RESULT = e.getMessage();
					}
				:}
				| SET_MODE_1 optionalDot
				{: 
					if(AP.getSnepslogMode()!=1) {
						AP.clearKnowledgeBase();
						AP.setSnepslogMode(1);
						RESULT = "The knowledge base is cleared, and SNePSLOG is put into Mode 1.";
					}else{
						RESULT = "Mode 1 is already in use.";
					}
				:}
				| SET_MODE_2 optionalDot
				{: 
					if(AP.getSnepslogMode()!=2) {
						AP.clearKnowledgeBase();
						AP.setSnepslogMode(2);
						RESULT = "The knowledge base is cleared, and SNePSLOG is put into Mode 2.";
					}else{
						RESULT = "Mode 2 is already in use.";
					}
				:}
				| SET_MODE_3 optionalDot
				{: 
					if(AP.getSnepslogMode()!=3) {
						AP.clearKnowledgeBase();
						AP.setSnepslogMode(3);
						RESULT = "The knowledge base is cleared, and SNePSLOG is put into Mode 3.";
					}else{
						RESULT = "Mode 3 is already in use.";
					}
				:}
				| SHOW pTermSet:pts optionalDot
				{: 
					Main.visualizeNodes(pts);
				:}
				| TRACE snepslogFunction:sf optionalDot
				{: 
					AP.activateTracing(sf);
					RESULT = "";
				:}
				| UNDEFINE_PATH IDENTIFIER:id optionalDot
				{: 
					try{
						if(AP.getSnepslogMode()==3){
							Network.undefinePath(Network.getRelation(id));
							RESULT = "";
						}else{
							RESULT = "You can only use this command in Mode 3.";
						}
					} catch(RelationDoesntExistException e){
						RESULT = e.getMessage();
					} catch (Exception e) {
						RESULT = e.getMessage();
					}
				:}
				| UNLABELED optionalDot
				{: 
					if(!AP.getPrintingMode().equals("unlabeled")) {
						AP.setPrintingMode("unlabeled");
						RESULT = "unlabeled mode is turned on.";
					}else{
						RESULT = "unlabeled mode is already in use.";
					}
				:}
				| UNTRACE snepslogFunction:sf optionalDot
				{: 
					AP.deactivateTracing(sf);
					RESULT = "";
				:};	

snepslogFunction ::=	 INFERENCE
		     	{:
					RESULT = "inference";
		     	:}
		      	| ACTING
		     	{:
					RESULT = "acting";
		     	:};
				
wff ::= infixedTerm:it
    {:
    		RESULT = it;
    :}
    | entailment:e
    {:
    		RESULT = e;
    :};				

infixedTerm ::= prefixedTerm:arg1 andOrEquality:type infixedTerm:arg2
            {:
            		try{
    					RESULT = AP.buildInfixedTerm(type, arg1, arg2);
    				} catch(EquivalentNodeException e){
						warning = e.getMessage();
						RESULT = e.getEquivalentNode();
				}
            :}
            | prefixedTerm:pt
            {:
            		RESULT = pt;
            :};

andOrEquality ::= AND
                   {:
             			RESULT = "and";
                   :}
                   | OR
                   {:
             			RESULT = "or";
                   :}
                   | EQUALITY
                   {:
             			RESULT = "equality";
                   :};

entailment ::= termSet:antecedents IMPLICATION termSet:consequents
           {:
    				try{
    					RESULT = AP.buildEntailment("Implication", antecedents, consequents, null);
           		} catch(EquivalentNodeException e){
						warning = e.getMessage();
						RESULT = e.getEquivalentNode();
				}
           :}
           | termSet:antecedents OR_ENTAILMENT termSet:consequents
           {:
           		try{
           			RESULT = AP.buildEntailment("OrEntailment", antecedents, consequents, null);
				} catch(EquivalentNodeException e){
						warning = e.getMessage();
						RESULT = e.getEquivalentNode();
				}
           :}
           | termSet:antecedents AND_ENTAILMENT termSet:consequents
           {:
           		try{
           			RESULT = AP.buildEntailment("AndEntailment", antecedents, consequents, null);
           		} catch(EquivalentNodeException e){
						warning = e.getMessage();
						RESULT = e.getEquivalentNode();
				}
           :}
           | termSet:antecedents NUMERICAL_ENTAILMENT:ne termSet:consequents
           {:
           		try{
           			RESULT = AP.buildEntailment("NumericalEntailment", antecedents, consequents, ne.substring(0,ne.length()-2));
           		} catch(EquivalentNodeException e){
						warning = e.getMessage();
						RESULT = e.getEquivalentNode();
				}
           :};
		
pTermSet ::= termSet:ts
         {:
    			ArrayList<Node> out = new ArrayList<Node>();
			for (int i = 0; i < ts.size(); i++) {
				ArrayList<Node> temp = AP.match(ts.get(i));
				for (int j = 0; j < temp.size(); j++) {
					out.add(temp.get(j));
				}
			}
			RESULT = out;
         :};		

termSet ::=	prefixedTerm:pt
		{:
			ArrayList<Node> temp = new ArrayList<Node>();
			temp.add(pt);
			RESULT = temp;
		:}
		| OPEN_CURLY termSequence:ts CLOSE_CURLY
		{:
			RESULT = ts;
		:};
		
termSequence ::= prefixedTerm:pt prefixedTerms:pts
             {:
             	ArrayList<Node> out = new ArrayList<Node>();
             	out.add(pt);
				for (int i = 0; i < pts.size(); i++) {
					out.add(pts.get(i));				
				}
				RESULT = out;
             :};
	     	
prefixedTerms ::= COMMA prefixedTerm:pt prefixedTerms:pts
			  {:
					ArrayList<Node> out = new ArrayList<Node>();
             		out.add(pt);
					for (int i = 0; i < pts.size(); i++) {
						out.add(pts.get(i));				
					}
					RESULT = out;
			  :}
			  | 
			  {:
					ArrayList<Node> out = new ArrayList<Node>();
					RESULT = out;
		      :};
		     
prefixedTerm ::= negatedTerm:t
			 {:
				RESULT = t;
			 :}
			 | andorTerm:t
			 {:
				RESULT = t;
		     :}
		     | setTerm:t
			 {:
				RESULT = t;
		     :}
		     | threshTerm:t
			 {:
				RESULT = t;
		     :}
		     | ifdoTerm:t
			 {:
				RESULT = t;
		     :}
		     | whendoTerm:t
			 {:
				RESULT = t;
		     :}
		     | wheneverdoTerm:t
			 {:
				RESULT = t;
		     :}
		     | actplanTerm:t
			 {:
				RESULT = t;
		     :}
		     | effectTerm:t
			 {:
				RESULT = t;
		     :}
		     | goalplanTerm:t
			 {:
				RESULT = t;
		     :}
		     | preconditionTerm:t
			 {:
				RESULT = t;
		     :}
		     | allTerm:t
			 {:
				RESULT = t;
		     :}
		     | atomicTerm:t
			 {:
				RESULT = t;
		     :};
		     
negatedTerm ::= NOT atomicTerm:node
		    {:
		    		try{
					RESULT = AP.buildNegatedTerm(node);
				} catch(EquivalentNodeException e){
						warning = e.getMessage();
						RESULT = e.getEquivalentNode();
				}
			:};
			
andorTerm ::= ANDOR OPEN_PARAN INT_LIT:i COMMA INT_LIT:j CLOSE_PARAN termSet:arguments
		  {:
		  		if(Integer.valueOf(i)>=0&&Integer.valueOf(i)<=Integer.valueOf(j)){
		  			try{
						RESULT = AP.buildAndorTerm(i, j, arguments);
					} catch(EquivalentNodeException e){
						warning = e.getMessage();
						RESULT = e.getEquivalentNode();
					}
				}
				else{
					throw new InvalidArgumentsException("The arguments should be something like: 0<=i<=j");
				}
		  :};
	
setTerm ::= AND termSet:arguments
        {:
        		try{
             	RESULT = AP.buildSetTerm("and", arguments);
             } catch(EquivalentNodeException e){
             	warning = e.getMessage();
				RESULT = e.getEquivalentNode();
			}
        :}
        | OR termSet:arguments
        {:
             try{
             	RESULT = AP.buildSetTerm("or", arguments);
             } catch(EquivalentNodeException e){
             	warning = e.getMessage();
				RESULT = e.getEquivalentNode();
			}
        :}
        | NAND termSet:arguments
        {:
             try{
             	RESULT = AP.buildSetTerm("nand", arguments);
             } catch(EquivalentNodeException e){
             	warning = e.getMessage();
				RESULT = e.getEquivalentNode();
			}
        :}
        | NOR termSet:arguments
        {:
             try{
             	RESULT = AP.buildSetTerm("nor", arguments);
             } catch(EquivalentNodeException e){
             	warning = e.getMessage();
				RESULT = e.getEquivalentNode();
			}
        :}
        | XOR termSet:arguments
        {:
             try{
             	RESULT = AP.buildSetTerm("xor", arguments);
             } catch(EquivalentNodeException e){
             	warning = e.getMessage();
				RESULT = e.getEquivalentNode();
			}
        :}
        | IFF termSet:arguments
        {:
             try{
             	RESULT = AP.buildSetTerm("iff", arguments);
             } catch(EquivalentNodeException e){
             	warning = e.getMessage();
				RESULT = e.getEquivalentNode();
			}
        :};

threshTerm ::= THRESH OPEN_PARAN INT_LIT:thresh COMMA INT_LIT:threshmax CLOSE_PARAN termSet:arguments
           {:
           		if(Integer.valueOf(thresh)>=0&&Integer.valueOf(thresh)<=Integer.valueOf(threshmax)){
           			try{
						RESULT = AP.buildThreshTerm(thresh, threshmax, arguments);
					} catch(EquivalentNodeException e){
             			warning = e.getMessage();
						RESULT = e.getEquivalentNode();
					}
				}
				else{
					throw new InvalidArgumentsException("The arguments should be something like: 0<=i<=j");
				}
           :}
           | THRESH OPEN_PARAN INT_LIT:thresh CLOSE_PARAN termSet:arguments
           {:
           		if(Integer.valueOf(thresh)>=0){
           			try{
						RESULT = AP.buildThreshTerm(thresh, arguments.size()-1+"", arguments);
					} catch(EquivalentNodeException e){
             			warning = e.getMessage();
						RESULT = e.getEquivalentNode();
					}
				}
				else{
					throw new InvalidArgumentsException("The arguments should be something like: 0<=i");
				}
           :};

ifdoTerm ::= IFDO OPEN_PARAN wff:arg1 COMMA atomicTerm:arg2 CLOSE_PARAN
         {:
         		if(AP.getSnepslogMode()==3){
         			try{
           				RESULT = AP.buildSNeRETerm("ifdo", arg1, arg2);
           			} catch(EquivalentNodeException e){
             			warning = e.getMessage();
						RESULT = e.getEquivalentNode();
					}
           		}else{
           			throw new ModeThreeOnlyException("SNeRE in SNePSLOG is only allowed in Mode 3");
           		}
		 :};
		 
whendoTerm ::= WHENDO OPEN_PARAN wff:arg1 COMMA atomicTerm:arg2 CLOSE_PARAN
           {:
           		if(AP.getSnepslogMode()==3){
         			try{
           				RESULT = AP.buildSNeRETerm("whendo", arg1, arg2);
           			} catch(EquivalentNodeException e){
             			warning = e.getMessage();
						RESULT = e.getEquivalentNode();
					}
           		}else{
           			throw new ModeThreeOnlyException("SNeRE in SNePSLOG is only allowed in Mode 3");
           		}
		   :};
		   
wheneverdoTerm ::= WHENEVERDO OPEN_PARAN wff:arg1 COMMA atomicTerm:arg2 CLOSE_PARAN
               {:
				if(AP.getSnepslogMode()==3){
         			try{
           				RESULT = AP.buildSNeRETerm("wheneverdo", arg1, arg2);
           			} catch(EquivalentNodeException e){
             			warning = e.getMessage();
						RESULT = e.getEquivalentNode();
					}
           		}else{
           			throw new ModeThreeOnlyException("SNeRE in SNePSLOG is only allowed in Mode 3");
           		}
		       :};
		   
actplanTerm ::= ACTPLAN OPEN_PARAN atomicTerm:arg1 COMMA atomicTerm:arg2 CLOSE_PARAN
            {:
            		if(AP.getSnepslogMode()==3){
         			try{
           				RESULT = AP.buildSNeRETerm("ActPlan", arg1, arg2);
           			} catch(EquivalentNodeException e){
             			warning = e.getMessage();
						RESULT = e.getEquivalentNode();
					}
           		}else{
           			throw new ModeThreeOnlyException("SNeRE in SNePSLOG is only allowed in Mode 3");
           		}
		    :};
		       
effectTerm ::= EFFECT OPEN_PARAN atomicTerm:arg1 COMMA wff:arg2 CLOSE_PARAN
           {:
           		if(AP.getSnepslogMode()==3){
         			try{
           				RESULT = AP.buildSNeRETerm("Effect", arg1, arg2);
           			} catch(EquivalentNodeException e){
             			warning = e.getMessage();
						RESULT = e.getEquivalentNode();
					}
           		}else{
           			throw new ModeThreeOnlyException("SNeRE in SNePSLOG is only allowed in Mode 3");
           		}
	       :};
		       
goalplanTerm ::= GOALPLAN OPEN_PARAN wff:arg1 COMMA atomicTerm:arg2 CLOSE_PARAN
             {:
				if(AP.getSnepslogMode()==3){
         			try{
           				RESULT = AP.buildSNeRETerm("GoalPlan", arg1, arg2);
           			} catch(EquivalentNodeException e){
             			warning = e.getMessage();
						RESULT = e.getEquivalentNode();
					}
           		}else{
           			throw new ModeThreeOnlyException("SNeRE in SNePSLOG is only allowed in Mode 3");
           		}
		     :};		     

preconditionTerm ::= PRECONDITION OPEN_PARAN atomicTerm:arg1 COMMA wff:arg2 CLOSE_PARAN
                 {:
				if(AP.getSnepslogMode()==3){
         			try{
           				RESULT = AP.buildSNeRETerm("Precondition", arg1, arg2);
           			} catch(EquivalentNodeException e){
             			warning = e.getMessage();
						RESULT = e.getEquivalentNode();
					}
           		}else{
           			throw new ModeThreeOnlyException("SNeRE in SNePSLOG is only allowed in Mode 3");
           		}
		         :};

allTerm ::= ALL OPEN_PARAN symbolSequence:ss CLOSE_PARAN OPEN_PARAN wff:w CLOSE_PARAN
		{:
			if(w.getTerm() instanceof Base){
		   		throw new IllegalAtomicSymbolException("wff must not be an atomic symbol");
		   	}
		   	try{
				RESULT = AP.buildAllTerm(ss, w);
			} catch(EquivalentNodeException e){
             	warning = e.getMessage();
				RESULT = e.getEquivalentNode();
			}
		:};

atomicTerm ::= wffName:wn
           {:
           		RESULT = Network.getNodes().get("M"+wn.substring(3));
           :}
           | qvar:q
           {:
           		RESULT = q;
           :}
           | IDENTIFIER:id
           {:
           		RESULT = Network.buildBaseNode(id, Semantic.proposition);
           :}
           | IDENTIFIER:id1 COLON IDENTIFIER:id2
           {:
           		if(AP.getSnepslogMode()==3){
           			if (Network.getNodes().containsKey(id1)) {
           				throw new SemanticAlreadySetException("A semantic type was already set for this node");
					}else{
						RESULT = Network.buildBaseNode(id1, SemanticHierarchy.getSemantic(id2));
					}
           		}else{
           			throw new ModeThreeOnlyException("SNeRE in SNePSLOG is only allowed in Mode 3");
           		}
           :}
           | withsomeTerm:wst
           {:
           		RESULT = wst;
           :}
           | withallTerm:wat
           {:
           		RESULT = wat;
           :}
           | qvar:q OPEN_PARAN termSetSequence:tss CLOSE_PARAN
           {:
           		if(AP.getSnepslogMode()==1){
           			ArrayList<Wire> wires = new ArrayList<Wire>();
					CaseFrame caseFrame = AP.createModeOneCaseFrame(tss.size());
					LinkedList<Relation> relations = caseFrame.getRelations();
					wires.add(new Wire(relations.get(0),q));
					for(int i = 0;i<tss.size();i++){
						for(int j=0;j<tss.get(i).size();j++){
							wires.add(new Wire(relations.get(i+1),tss.get(i).get(j)));
						}
					}
					try{
						RESULT = Network.buildMolecularNode(wires, caseFrame);
					} catch(EquivalentNodeException e){
						warning = e.getMessage();
						RESULT = e.getEquivalentNode();
					}
				}else{
					throw new ModeOneOnlyException("A predicate can start with a variable only in Mode 1");
				}
           :}
           | IDENTIFIER:id OPEN_PARAN termSetSequence:tss CLOSE_PARAN
           {:
           		if(AP.getSnepslogMode()!=3){
           			ArrayList<Wire> wires = new ArrayList<Wire>();
					CaseFrame caseFrame = null;
					if(AP.getSnepslogMode()==1){
						caseFrame = AP.createModeOneCaseFrame(tss.size());
					}else{
						caseFrame = AP.createModeTwoCaseFrame(id, tss.size());					
					}
					LinkedList<Relation> relations = caseFrame.getRelations();
					wires.add(new Wire(relations.get(0), Network.buildBaseNode(id, Semantic.proposition)));
					for(int i = 0;i<tss.size();i++){
						for(int j=0;j<tss.get(i).size();j++){
							wires.add(new Wire(relations.get(i+1),tss.get(i).get(j)));
						}
					}
					try{
						RESULT = Network.buildMolecularNode(wires, caseFrame);
					} catch(EquivalentNodeException e){
						warning = e.getMessage();
						RESULT = e.getEquivalentNode();
					}
				}else{
					String description = "";
					boolean flag = false;
					if(AP.getCfsDescriptions().containsKey(id)){
						description = AP.getCfsDescriptions().get(id);
						flag = true;
					}
					if(AP.getModeThreeCaseFrames().containsKey(id)){
						ArrayList<Wire> wires = new ArrayList<Wire>();
						CaseFrame caseFrame = AP.getModeThreeCaseFrames().get(id);
						LinkedList<Relation> relations = caseFrame.getRelations();
						wires.add(new Wire(relations.get(0), Network.buildBaseNode(id, SemanticHierarchy.createSemanticType(caseFrame.getRelations().get(0).getType()))));
						if(flag){
							description = description.replaceAll(relations.get(0).getName(), id);
						}
						for(int i = 0;i<tss.size();i++){
							for(int j=0;j<tss.get(i).size();j++){
								wires.add(new Wire(relations.get(i+1),tss.get(i).get(j)));
								if(flag){
									description = description.replaceAll(relations.get(i+1).getName(), tss.get(i).get(j).getIdentifier());
								}
							}
						}
						try{
							Node node = Network.buildMolecularNode(wires, caseFrame);
							if(flag){
								Set<Node> keys = AP.getNodesDescriptions().keySet();
								for (Node key : keys) {
									description = description.replaceAll(key.getIdentifier()+" ", AP.getNodesDescriptions().get(key).substring(1,AP.getNodesDescriptions().get(key).length()-1)+" ");
								}
								AP.getNodesDescriptions().put(node, description);
							}
							RESULT = node;
						} catch(EquivalentNodeException e){
							warning = e.getMessage();
							RESULT = e.getEquivalentNode();
						}
					}else{
						if(AP.getModeThreeCaseFrames().containsKey(id+"$")){
							ArrayList<Wire> wires = new ArrayList<Wire>();
							CaseFrame caseFrame = AP.getModeThreeCaseFrames().get(id+"$");
							LinkedList<Relation> relations = caseFrame.getRelations();
							for(int i = 0;i<tss.size();i++){
								for(int j=0;j<tss.get(i).size();j++){
									wires.add(new Wire(relations.get(i),tss.get(i).get(j)));
									if(flag){
										description = description.replaceAll(relations.get(i).getName(), tss.get(i).get(j).getIdentifier());
									}
								}
							}
							try{
								Node node = Network.buildMolecularNode(wires, caseFrame);
								if(flag){
									Set<Node> keys = AP.getNodesDescriptions().keySet();
									for (Node key : keys) {
										description = description.replaceAll(key.getIdentifier()+" ", AP.getNodesDescriptions().get(key).substring(1,AP.getNodesDescriptions().get(key).length()-1)+" ");
									}
									AP.getNodesDescriptions().put(node, description);
								}
								RESULT = node;
							} catch(EquivalentNodeException e){
								warning = e.getMessage();
								RESULT = e.getEquivalentNode();
							}
						}else{
							throw new CannotFindCaseFrameException("Unable to find a matching CaseFrame.");
						}
					}
				}
           :}
           | OPEN_PARAN wff:w CLOSE_PARAN
           {:
           		RESULT = w;
           :};

withsomeTerm ::= WITHSOME OPEN_PARAN symbolSequence:vars CLOSE_PARAN OPEN_PARAN termSet:suchthat COMMA termSet:doo COMMA termSet:elsee CLOSE_PARAN
             {:
             	if(AP.getSnepslogMode()==3){
             		try{
           				RESULT = AP.buildWithsomeAllTerm("withsome", vars, suchthat, doo, elsee);
           			} catch(EquivalentNodeException e){
             			warning = e.getMessage();
						RESULT = e.getEquivalentNode();
					}
           		}else{
           			throw new ModeThreeOnlyException("SNeRE in SNePSLOG is only allowed in Mode 3");
           		}
             :}
             | WITHSOME OPEN_PARAN symbolSequence:vars CLOSE_PARAN OPEN_PARAN termSet:suchthat COMMA termSet:doo CLOSE_PARAN
             {:
             	if(AP.getSnepslogMode()==3){
             		try{
           				RESULT = AP.buildWithsomeAllTerm("withsome", vars, suchthat, doo, null);
           			} catch(EquivalentNodeException e){
             			warning = e.getMessage();
						RESULT = e.getEquivalentNode();
					}
           		}else{
           			throw new ModeThreeOnlyException("SNeRE in SNePSLOG is only allowed in Mode 3");
           		}
             :};
             
withallTerm ::= WITHALL OPEN_PARAN symbolSequence:vars CLOSE_PARAN OPEN_PARAN termSet:suchthat COMMA termSet:doo COMMA termSet:elsee CLOSE_PARAN
             {:
             	if(AP.getSnepslogMode()==3){
             		try{
           				RESULT = AP.buildWithsomeAllTerm("withall", vars, suchthat, doo, elsee);
           			} catch(EquivalentNodeException e){
             			warning = e.getMessage();
						RESULT = e.getEquivalentNode();
					}
           		}else{
           			throw new ModeThreeOnlyException("SNeRE in SNePSLOG is only allowed in Mode 3");
           		}
             :}
             | WITHALL OPEN_PARAN symbolSequence:vars CLOSE_PARAN OPEN_PARAN termSet:suchthat COMMA termSet:doo CLOSE_PARAN
             {:
             	if(AP.getSnepslogMode()==3){
             		try{
           				RESULT = AP.buildWithsomeAllTerm("withall", vars, suchthat, doo, null);
           			} catch(EquivalentNodeException e){
             			warning = e.getMessage();
						RESULT = e.getEquivalentNode();
					}
           		}else{
           			throw new ModeThreeOnlyException("SNeRE in SNePSLOG is only allowed in Mode 3");
           		}
             :};
		         
termSetSequence ::= termSet:ts termSets:tss
                {:
					ArrayList<ArrayList<Node>> out = new ArrayList<ArrayList<Node>>();
             		out.add(ts);
					for (int i = 0; i < tss.size(); i++) {
						out.add(tss.get(i));				
					}
					RESULT = out;
		        :};

termSets ::= COMMA termSet:ts termSets:tss
	     {:
			tss.add(0, ts);
			RESULT = tss;
	     :}
	     | 
		 {:
			RESULT = new ArrayList<ArrayList<Node>>();
		 :};
		 
symbolSequence ::= snepslogSymbol:ss snepslogSymbols:sss
               {:
					ArrayList<Node> out = new ArrayList<Node>();
             		out.add(ss);
					for (int i = 0; i < sss.size(); i++) {
						out.add(sss.get(i));				
					}
					RESULT = out;
		       :};

snepslogSymbols ::= COMMA snepslogSymbol:ss snepslogSymbols:sss
	            {:
	            		sss.add(ss);
					RESULT = sss;
	            :}
	            | 
		        {:
					RESULT = new ArrayList<Node>();
		        :};

wffName ::= WFF:w
	    {:
	    		if (Network.getNodes().containsKey("M"+w.substring(3))) {
        			RESULT = w;
			}else{
				throw new InvalidWffNameException("This wffName does not correspond to any wff in the Network");
			}
	    :};
	    
qvar ::= QUESTION_MARK IDENTIFIER:id
	 {:
		RESULT = Network.buildVariableNode(id);
	 :};

snepslogSymbol ::= IDENTIFIER:id
               {:
               		VariableNode vNode = Network.buildVariableNode(id);
					vNode.setSnepslogFlag(true);
					RESULT = vNode;
               :};

terminalPunctuation ::= DOT
                    {:
           				RESULT = ".";
                    :}
                    | BANG
                    {:
                     	RESULT = "!";
                    :}
                    | QUESTION_MARK QUESTION_MARK
                    {:
           				RESULT = "??";
                    :}
                    | QUESTION_MARK
                    {:
           				RESULT = "?";
                    :}
                    | QUESTION_MARK OPEN_PARAN INT_LIT:il CLOSE_PARAN
                    {:
           				RESULT = "ONE"+il;
                    :}
                    | QUESTION_MARK OPEN_PARAN INT_LIT:il1 INT_LIT:il2 CLOSE_PARAN
                    {:
           				RESULT = "TWO"+il1+","+il2;
                    :};
							
optionalDot ::= DOT
			{:
				RESULT = ".";
			:}
			| 
			{:
				RESULT = null;
			:};	

optionalIdentifier ::= IDENTIFIER:id
			       {:
			       		RESULT = id;
			       :}
			       |
			       {:
			       		RESULT = null;
			       :};
			
optionalTerminalPunctuation ::= terminalPunctuation:tp
							{:
								RESULT = tp;
							:}
							| 
							{:
								RESULT = null;
							:};					
							
optionalPTermSet ::=	 pTermSet:pts
				 {:
					RESULT = pts;
				 :}
				 | 
				 {:
					RESULT = null;
				 :};		

identifiers ::= IDENTIFIER:id identifiers:ids
            {:
            		ids.add(0, id);
            		RESULT = ids;
            :}
            |
            {:
				RESULT = new ArrayList<String>();
            :};

identifiers_list ::= OPEN_PARAN IDENTIFIER:id identifiers:ids CLOSE_PARAN
                 {:
                 	ArrayList<String> out = new ArrayList<String>();
             		out.add(id);
					for (int i = 0; i < ids.size(); i++) {
						out.add(ids.get(i));				
					}
					RESULT = out;
                 :};			          	

path ::= snepsPath:sp
     {:
     	RESULT = sp;
     :}
     | BANGPATH
     {:
     	RESULT = new BangPath();
     :}
     | EMPTYPATH
     {:
     	RESULT = new EmptyPath();
     :};
						
snepsPath ::= IDENTIFIER:id
	      {:
				if(id.charAt(id.length()-1)=='-'){
					RESULT = new BUnitPath(Network.getRelation(id));
				}else{
					RESULT = new FUnitPath(Network.getRelation(id));
				}
          :}
	      | CFRES OPEN_PARAN IDENTIFIER:id1 COMMA IDENTIFIER:id2 CLOSE_PARAN
        	  {:
				if(id1.charAt(id1.length()-1)=='-'){
					RESULT = new CFResBUnitPath(Network.getRelation(id1), Network.getCaseFrame(id2));
				}else{
					RESULT = new CFResFUnitPath(Network.getRelation(id1), Network.getCaseFrame(id2));
				}
	      :}
     	  | KPLUS OPEN_PARAN path:p CLOSE_PARAN
	      {:
				RESULT = new KPlusPath(p);
	      :}
	      | KSTAR OPEN_PARAN path:p CLOSE_PARAN
	      {:
				RESULT = new KStarPath(p);
	      :}
	      | AND OPEN_PARAN paths:ps CLOSE_PARAN
	      {:
				RESULT = new AndPath(ps);
	      :}
	      | AND OPEN_PARAN CLOSE_PARAN
	      {:
				RESULT = new AndPath(new LinkedList<Path>());
	      :}
	      | OR OPEN_PARAN paths:ps CLOSE_PARAN
	      {:
				RESULT = new OrPath(ps);
     	 :}
	      | OR OPEN_PARAN CLOSE_PARAN
	      {:
				RESULT = new OrPath(new LinkedList<Path>());
	      :}
	      | COMPOSE OPEN_PARAN paths:ps CLOSE_PARAN
	      {:
				RESULT = new ComposePath(ps);
	      :}
	      | COMPOSE OPEN_PARAN CLOSE_PARAN
	      {:
				RESULT = new ComposePath(new LinkedList<Path>());
	      :}
	      | CONVERSE OPEN_PARAN path:p CLOSE_PARAN
	      {:
				RESULT = new ConversePath(p);
	      :}
	      | IRREFLEXIVE_RESTRICT OPEN_PARAN path:p CLOSE_PARAN
	      {:
				RESULT = new IrreflexiveRestrictPath(p);
	      :}
	      | DOMAIN_RESTRICT OPEN_PARAN path:p1 OPEN_PARAN wff:w CLOSE_PARAN COMMA path:p2 CLOSE_PARAN
	      {:
				RESULT = new DomainRestrictPath(p1,w,p2);
	      :}
	      | RANGE_RESTRICT OPEN_PARAN path:p1 COMMA path:p2 OPEN_PARAN wff:w CLOSE_PARAN CLOSE_PARAN
	      {:
				RESULT = new RangeRestrictPath(p1,p2,w);
	      :};
	 
paths ::= path:p COMMA paths:ps
      {:
      		ps.add(p);
      		RESULT = ps;
      :}
      | path:p
      {:
      		LinkedList<Path> out = new LinkedList<Path>();
      		out.add(p);
      		RESULT = out;
      :};
				 																																																																																																																																																										